#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>

using namespace std;

class NavetteStade {
private:
    mutex mtx;                            // Mutex pour protéger l'accès aux variables d'état
    condition_variable cv;                // Variable conditionnelle pour synchroniser les threads
    int supportersPSG = 0;               // Nombre total de supporters du PSG en attente
    int supportersOM = 0;                // Nombre total de supporters de l'OM en attente
    int embarques_PSG = 0;              // Nombre de supporters du PSG actuellement à bord
    int embarques_OM = 0;               // Nombre de supporters de l'OM actuellement à bord

public:
    void monter(bool estPSG) {
        unique_lock<mutex> verrou(mtx); // crée un objet de type unique_lock

        if (estPSG) {
            supportersPSG++;
        } else {
            supportersOM++;
        }

        // Attendre jusqu'à ce qu'il soit sûr de monter à bord
        cv.wait(verrou, [&]() {
            return ((supportersPSG >= 4 && embarques_OM == 0) || 
                    (supportersOM >= 4 && embarques_PSG == 0) ||
                    (supportersPSG >= 2 && supportersOM >= 2 && 
                     embarques_PSG + embarques_OM == 0));
        });

        if (estPSG && embarques_PSG < 4) {
            supportersPSG--;
            embarques_PSG++;
            cout << "Un supporter du PSG monte à bord.\n";
        } else if (!estPSG && embarques_OM < 4) {
            supportersOM--;
            embarques_OM++;
            cout << "Un supporter de l'OM monte à bord.\n";
        }

        // Si la navette est pleine, réinitialisez les compteurs et naviguez
        if (embarques_PSG + embarques_OM == 4) {
            naviguer();
            embarques_PSG = 0;
            embarques_OM = 0;
            cv.notify_all(); // tous les threads qui étaient en attente se réveille
        } else {
            cv.notify_one(); // notifier un autre supporter pour vérifier s'il peut monter.
        }
    }

    void naviguer() {
        cout << "La navette démarre vers le stade!\n\n";
    }
};

void tachePSG(NavetteStade& ns) {
    ns.monter(true);
}

void tacheOM(NavetteStade& ns) {
    ns.monter(false);
}

int main() {
    NavetteStade ns;

    thread psgSupporters[20];
    thread omSupporters[20];

    // Créer 20 threads pour les supporters du PSG et 20 pour les supporters de l'OM
    for (int i = 0; i < 20; i++) {
        psgSupporters[i] = thread(tachePSG, ref(ns));
        omSupporters[i] = thread(tacheOM, ref(ns));
    }

    // Attendre que tous les threads se terminent
    for (int i = 0; i < 20; i++) {
        psgSupporters[i].join();
        omSupporters[i].join();
    }

    return 0;
}
